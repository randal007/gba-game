#!/usr/bin/env python3
"""Convert Pixel's 32x16 tile PNGs into GBA 8bpp tile data for metatile engine.

Each 32x16 PNG becomes a metatile: 4x2 arrangement of 8x8 tiles.
Outputs C arrays with unified 256-color palette.
"""
import os
import sys
from PIL import Image

TILES_DIR = os.path.join(os.path.dirname(__file__), '..', 'assets', 'tiles')
OUT_DIR = os.path.join(os.path.dirname(__file__), '..', 'data')

# Tile types in order (ground first, then sides)
GROUND_TILES = ['ground_grass', 'ground_stone', 'ground_dirt', 'ground_water', 'ground_roof']
SIDE_TILES = ['side_grass_edge', 'side_stone_wall', 'side_dirt_wall', 'side_brick_wall', 'side_roof_edge']
ALL_TILES = GROUND_TILES + SIDE_TILES

def rgb_to_gba(r, g, b):
    """Convert 8-bit RGB to GBA 15-bit BGR."""
    return ((b >> 3) << 10) | ((g >> 3) << 5) | (r >> 3)

def main():
    # Build unified palette: index 0 = transparent (color 0)
    palette = [(0, 0, 0)]  # index 0 = transparent/background
    color_to_idx = {}
    
    # Load all images and collect colors
    images = {}
    for name in ALL_TILES:
        path = os.path.join(TILES_DIR, f'{name}.png')
        img = Image.open(path).convert('RGBA')
        images[name] = img
        for y in range(img.height):
            for x in range(img.width):
                r, g, b, a = img.getpixel((x, y))
                if a < 128:
                    continue  # transparent
                rgb = (r, g, b)
                if rgb not in color_to_idx:
                    idx = len(palette)
                    if idx >= 256:
                        print(f"WARNING: palette overflow at {name}")
                        continue
                    palette.append(rgb)
                    color_to_idx[rgb] = idx
    
    print(f"Unified palette: {len(palette)} colors")
    
    # Extract 8x8 tiles from each 32x16 image (4 cols x 2 rows)
    # metatile_tiles[name] = list of 8 tile data arrays (row-major: [0,0],[1,0],[2,0],[3,0],[0,1],[1,1],[2,1],[3,1])
    all_unique_tiles = [bytes(64)]  # tile 0 = all transparent
    tile_hash = {bytes(64): 0}
    metatile_defs = {}  # name -> list of 8 tile indices
    
    for name in ALL_TILES:
        img = images[name]
        tile_indices = []
        for ty in range(2):
            for tx in range(4):
                tile_data = bytearray(64)
                for py in range(8):
                    for px in range(8):
                        ix = tx * 8 + px
                        iy = ty * 8 + py
                        if ix >= img.width or iy >= img.height:
                            tile_data[py * 8 + px] = 0
                            continue
                        r, g, b, a = img.getpixel((ix, iy))
                        if a < 128:
                            tile_data[py * 8 + px] = 0
                        else:
                            rgb = (r, g, b)
                            tile_data[py * 8 + px] = color_to_idx.get(rgb, 0)
                
                tb = bytes(tile_data)
                if tb in tile_hash:
                    tile_indices.append(tile_hash[tb])
                else:
                    idx = len(all_unique_tiles)
                    tile_hash[tb] = idx
                    all_unique_tiles.append(tb)
                    tile_indices.append(idx)
        
        metatile_defs[name] = tile_indices
        print(f"  {name}: tiles {tile_indices}")
    
    print(f"Total unique 8x8 tiles: {len(all_unique_tiles)}")
    
    # Write C output
    with open(os.path.join(OUT_DIR, 'metatiles.c'), 'w') as f:
        f.write('// Auto-generated by convert_tiles.py — DO NOT EDIT\n')
        f.write('#include "metatiles.h"\n\n')
        
        # Palette (GBA 15-bit)
        f.write(f'const unsigned short mt_palette[{len(palette)}] = {{\n')
        for i, (r, g, b) in enumerate(palette):
            gba = rgb_to_gba(r, g, b)
            f.write(f'    0x{gba:04X}{"," if i < len(palette)-1 else ""}'
                    f'  // {i}: ({r},{g},{b})\n')
        f.write('};\n\n')
        
        # Tile pixel data (8bpp, 64 bytes per tile)
        f.write(f'const unsigned char mt_tile_pixels[{len(all_unique_tiles)}][64] = {{\n')
        for ti, td in enumerate(all_unique_tiles):
            f.write('    {')
            for j, b in enumerate(td):
                if j > 0 and j % 16 == 0:
                    f.write('\n     ')
                f.write(f'{b},')
            f.write(f'}},  // tile {ti}\n')
        f.write('};\n\n')
        
        # Metatile definitions: each is 8 tile indices (4 cols x 2 rows)
        f.write('const unsigned short mt_metatile_tiles[MT_COUNT][8] = {\n')
        for name in ALL_TILES:
            indices = metatile_defs[name]
            f.write(f'    {{ {", ".join(str(i) for i in indices)} }},  // {name}\n')
        f.write('};\n')
    
    with open(os.path.join(OUT_DIR, 'metatiles.h'), 'w') as f:
        f.write('// Auto-generated by convert_tiles.py — DO NOT EDIT\n')
        f.write('#ifndef METATILES_H\n#define METATILES_H\n\n')
        f.write(f'#define MT_PALETTE_SIZE {len(palette)}\n')
        f.write(f'#define MT_TILE_COUNT {len(all_unique_tiles)}\n')
        f.write(f'#define MT_COUNT {len(ALL_TILES)}\n\n')
        
        # Metatile name indices
        for i, name in enumerate(ALL_TILES):
            f.write(f'#define MT_{name.upper()} {i}\n')
        
        f.write('\nextern const unsigned short mt_palette[];\n')
        f.write('extern const unsigned char mt_tile_pixels[][64];\n')
        f.write('extern const unsigned short mt_metatile_tiles[][8];\n')
        f.write('\n#endif // METATILES_H\n')
    
    print(f"\nWrote {OUT_DIR}/metatiles.c and metatiles.h")

if __name__ == '__main__':
    main()
